#ifndef _global_
#define _global_

enum enum_Enidan	{	eHOST,		eNET	};

enum enum_SendRecv	{	eSEND,		eRECV	};

enum enum_FieldType
{
	eDEFAULT,
	eCHAR,		eUCHAR,
	eSHORT,		eUSHORT,
	eINT,		eUINT,
	eLONG,		eULONG,
	eFLOAT,			//	EUFLOAT,
	eDOUBLE,		//	EUDOUBLE,		//无效
	eGRP8BIT,
	eGRP16BIT,
	eGRP32BIT,
	eBIT1,
	eBIT2,
	eBIT3,
	eBIT4
};
static int size_bit(enum_FieldType fieldType)
{
	switch (fieldType)
	{
	case eBIT1:return 1; break;
	case eBIT2:return 2; break;
	case eBIT3:return 3; break;
	case eBIT4:return 4; break;
	default:
		;
	}
}

static int size_MsgFld(enum_FieldType fieldType)
{
	switch (fieldType)
	{
	case eBIT1:
	case eBIT2:
	case eBIT3:
	case eBIT4:
		return 0; break;
	case eDEFAULT:
		return 0; break;
	case eCHAR:
	case eUCHAR:
	case eGRP8BIT:
		return 1; break;
	case eSHORT:
	case eUSHORT:
	case eGRP16BIT:
		return 2; break;
	case eINT:
	case eUINT:
	case eLONG:
	case eULONG:
	case eFLOAT:
	case eGRP32BIT:
		return 4; break;
	case eDOUBLE:
		return 8; break;
	default:
		;
	}
}

#endif

//static void test_BitGrp()
//{
//	uchar xc = 15 * 16;
//	qDebug() << QString::number(7, 2) << QString::number(mergeGrp((uchar)7, 1, 3, (uchar)0), 2);
//	qDebug() << QString::number(mergeGrp((uchar)7, 1, 3, (uchar)0), 2) << mergeGrp((uchar)7, 1, 3, (uchar)0);
//	ushort us = 255 * 16;
//	qDebug() << QString::number(us, 2) << QString::number(mergeGrp((ushort)3, 13, 3, (ushort)us), 2);
//	qDebug() << QString::number(us, 2) << QString::number(splitGrp((ushort)us, 10, 4), 2);
//
//	qDebug() << QString::number(18) << QString::number(18).toInt();
//
//	QString s = QString::number(18);
//	QString s1 = QString::number(s.toInt(), 2);
//	QString s2 = QString::number(3, 2);
//
//	qDebug() << s1 << s2;					s1 += s2;
//	qDebug() << s1 << s1.size() << s1.toUInt(0, 2);
//}

/////////////////////////////////////////////////////////
//
//报文通过xml来进行管理，方便配置和修改。				不少银行中间业务平台都能够方便的进行通讯报文的修改和配置
//对每一个报文定义类似下面的一个xml结构
//
//自己写的
//typedef struct{
//	int	iID;		//字段序号	//唯一性标识是哪一块域
//	int	iType;		//字段类型 
//	int	iDataType;	//字段数据类型 1-字符型；2-网络字节序
//	char*	sFldNm;		//字段名称
//	int	iLen;		//字段的长度
//}typFld;
//
//typedef struct{
//	int	iCnt;		//报文中字段的数目
//	typFld *FldPtr;		//在程序中动态分配空间
//}typFlds;
//
//struct typMsg
//{
//	int		iMsgID;		//报文ID
//	int		iType;		//报文类型
//	char 	*sMsgNm;	//报文名称
//	int 	iAnsMsgID;	//回应报文的报文ID
//	int 	iDirect;	//报文的方向，0--传入;1--传出
//	struct 	typFlds *FldsPtr;//指向存储各字段的配置信息的存储区域的指针
//};
//
//但是后来我发现报文中有一些特殊情况，采用上面的方式是不能处理的，如：
//有一些报文段是需要循环的，具体循环的次数是在程序运行中才能知道的，比如说，用户多个月的欠费明细就是这种情况。
//还有，有一些报文段是可能有，可能没有的，比如说：如果用户有欠费，回应报文中就会有用户各月的欠费明细，
//如果用户没有欠费，回应报文就只返回一个错误码，而没有任何的欠费明细，这些情况可能会混合起来，
//报文的xml结构如下：
//
//因为Fields节点中现在有不同的节点了：Field, While, Loop, 有些朋友的意见是在Field节点中使用链表的形式。
//我考虑了一下，觉得链表的编程太繁琐，还是希望使用数组的形式。编程简单。
//对应的程序中的结构修改如下：
//typedef struct{
//	int	iType;		//0-报文字段1-循环开始2-循环结束3-条件开始4-条件结束
//	char	*sLpCnt;	//循环次数表达式
//	char	*sWhile;	//条件表达式
//	int		iID;		//字段序号
//	int		iFldType;	//字段类型
//	int		iDataType;	//字段数据类型 1-字符型；2-网络字节序
//	char	*sFldNm;	//字段名称
//	int		iLen;		//字段的长度
//}typFld;
//
//当在程序中使用的时候，比如说，根据定义的报文结构读取一个报文时，
//"Field"节点, 就根据这个节点的属性读取相应长度的字段；
//"While"节点，就转化子节点中的条件表达式，如果表达式为真，就读取while中的其他子节点，如果为假，就跳到节点的下一个兄弟节点;
//"Loop"节点，就根据节点中的表达式的值重复读取中的其他子节点。